locals {
  lambda_code = <<-EOF
import json
import boto3
import os
from datetime import datetime
from decimal import Decimal

dynamodb = boto3.resource('dynamodb')
table_name = os.environ.get('DYNAMODB_TABLE')
table = dynamodb.Table(table_name)

class DecimalEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, Decimal):
            return float(obj)
        return super(DecimalEncoder, self).default(obj)

def handler(event, context):
    print(f"Event: {json.dumps(event)}")
    
    http_method = event.get('requestContext', {}).get('http', {}).get('method', 'GET')
    
    try:
        if http_method == 'GET':
            return get_items(event)
        elif http_method == 'POST':
            return create_item(event)
        elif http_method == 'PUT':
            return update_item(event)
        elif http_method == 'DELETE':
            return delete_item(event)
        else:
            return response(405, {'error': 'Method not allowed'})
    except Exception as e:
        print(f"Error: {str(e)}")
        return response(500, {'error': str(e)})

def get_items(event):
    path_params = event.get('pathParameters', {})
    
    if path_params and 'id' in path_params:
        result = table.get_item(Key={'id': path_params['id']})
        item = result.get('Item')
        if not item:
            return response(404, {'error': 'Item not found'})
        return response(200, item)
    else:
        result = table.scan(Limit=100)
        items = result.get('Items', [])
        return response(200, {'items': items, 'count': len(items)})

def create_item(event):
    try:
        body = json.loads(event.get('body', '{}'))
        if not body:
            return response(400, {'error': 'Empty request body'})
        
        if 'id' not in body:
            import uuid
            body['id'] = str(uuid.uuid4())
        
        body['created_at'] = datetime.utcnow().isoformat()
        body['updated_at'] = datetime.utcnow().isoformat()
        
        table.put_item(Item=body)
        return response(201, {'message': 'Item created', 'item': body})
    except json.JSONDecodeError:
        return response(400, {'error': 'Invalid JSON'})

def update_item(event):
    try:
        path_params = event.get('pathParameters', {})
        if not path_params or 'id' not in path_params:
            return response(400, {'error': 'Item ID required'})
        
        body = json.loads(event.get('body', '{}'))
        item_id = path_params['id']
        
        result = table.get_item(Key={'id': item_id})
        if 'Item' not in result:
            return response(404, {'error': 'Item not found'})
        
        body['id'] = item_id
        body['updated_at'] = datetime.utcnow().isoformat()
        table.put_item(Item=body)
        
        return response(200, {'message': 'Item updated', 'item': body})
    except json.JSONDecodeError:
        return response(400, {'error': 'Invalid JSON'})

def delete_item(event):
    path_params = event.get('pathParameters', {})
    if not path_params or 'id' not in path_params:
        return response(400, {'error': 'Item ID required'})
    
    item_id = path_params['id']
    result = table.get_item(Key={'id': item_id})
    if 'Item' not in result:
        return response(404, {'error': 'Item not found'})
    
    table.delete_item(Key={'id': item_id})
    return response(200, {'message': 'Item deleted'})

def response(status_code, body):
    return {
        'statusCode': status_code,
        'headers': {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
        },
        'body': json.dumps(body, cls=DecimalEncoder)
    }
EOF
}

data "archive_file" "lambda_zip" {
  type        = "zip"
  output_path = "${path.module}/lambda_function.zip"
  
  source {
    content  = local.lambda_code
    filename = "index.py"
  }
}

resource "aws_lambda_function" "api" {
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = "${var.project_name}-api"
  role            = aws_iam_role.lambda.arn
  handler         = "index.handler"
  source_code_hash = data.archive_file.lambda_zip.output_base64sha256
  runtime         = "python3.11"
  timeout         = 30
  memory_size     = 128

  # vpc_config {
  #   subnet_ids         = aws_subnet.private[*].id
  #   security_group_ids = [aws_security_group.lambda.id]
  # }

  environment {
    variables = {
      DYNAMODB_TABLE = aws_dynamodb_table.main.name
      ENVIRONMENT    = var.environment
    }
  }
}

resource "aws_cloudwatch_log_group" "lambda" {
  name              = "/aws/lambda/${aws_lambda_function.api.function_name}"
  retention_in_days = 7
}
